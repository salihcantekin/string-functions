@page "/json-to-typescript"

<SeoHead Route="json-to-typescript" />
@using System.Text.Json

<PageTitle>JSON to TypeScript</PageTitle>

<ToolPageLayout Title="JSON to TypeScript" Description="Generate TypeScript interface definitions from JSON.">
    <OptionsContent>
        <div class="option-group">
            <span class="option-label">Interface:</span>
            <FluentTextField @bind-Value="@rootInterfaceName" Placeholder="RootObject" Style="width: 120px;" @bind-Value:after="GenerateTypeScript" />
        </div>
        <div class="option-divider"></div>
        <FluentCheckbox @bind-Value="@useInterface" Label="Interface" @bind-Value:after="GenerateTypeScript" />
        <FluentCheckbox @bind-Value="@useOptional" Label="Optional" @bind-Value:after="GenerateTypeScript" />
        <FluentCheckbox @bind-Value="@exportTypes" Label="Export" @bind-Value:after="GenerateTypeScript" />
        <FluentCheckbox @bind-Value="@usePascalCase" Label="PascalCase" @bind-Value:after="GenerateTypeScript" />
    </OptionsContent>
    <ChildContent>
        <div class="json-tool-grid">
            <JsonInputArea Title="JSON Input"
                          @bind-Value="@inputJson"
                          Placeholder='{"name": "John", "age": 30, "isActive": true}'
                          ShowFormatButton="true"
                          ShowCopyButton="false"
                          AutoFormat="true"
                          OnError="OnJsonError" />

            <div class="output-panel">
                <div class="output-header">
                    <span class="output-title">TypeScript Code</span>
                    <CopyButton Text="@outputCode" />
                </div>
                <FluentTextArea Value="@outputCode" 
                               ReadOnly="true"
                               Resize="TextAreaResize.Vertical" />
            </div>
        </div>
    </ChildContent>
</ToolPageLayout>

<style>
    .json-tool-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        flex: 1;
    }

    .output-panel {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .output-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        height: 32px;
    }

    .output-title {
        font-weight: 600;
        font-size: 0.9rem;
        color: var(--text-primary);
    }

    @@media (max-width: 768px) {
        .json-tool-grid {
            grid-template-columns: 1fr;
            gap: 16px;
        }
    }
</style>

@code {
    private string inputJson = string.Empty;
    private string outputCode = string.Empty;
    private string rootInterfaceName = "RootObject";
    private bool useInterface = true;
    private bool useOptional = false;
    private bool exportTypes = true;
    private bool usePascalCase = true;
    private string? jsonError;

    private void OnJsonError(string? error)
    {
        jsonError = error;
        if (string.IsNullOrEmpty(error))
        {
            GenerateTypeScript();
        }
        else
        {
            outputCode = string.Empty;
        }
    }

    private void GenerateTypeScript()
    {
        if (string.IsNullOrWhiteSpace(inputJson))
        {
            outputCode = string.Empty;
            return;
        }

        try
        {
            using var doc = JsonDocument.Parse(inputJson);
            var code = new System.Text.StringBuilder();
            
            GenerateInterface(code, rootInterfaceName, doc.RootElement, 0);
            
            outputCode = code.ToString();
        }
        catch
        {
            outputCode = string.Empty;
        }
    }

    private void GenerateInterface(System.Text.StringBuilder sb, string interfaceName, JsonElement element, int indent)
    {
        var indentStr = new string(' ', indent * 2);
        var keyword = useInterface ? "interface" : "type";
        var exportKeyword = exportTypes ? "export " : "";
        var optional = useOptional ? "?" : "";
        
        if (useInterface)
        {
            sb.AppendLine($"{indentStr}{exportKeyword}interface {interfaceName} {{");
        }
        else
        {
            sb.AppendLine($"{indentStr}{exportKeyword}type {interfaceName} = {{");
        }

        if (element.ValueKind == JsonValueKind.Object)
        {
            var nestedTypes = new List<(string Name, JsonElement Element)>();
            
            foreach (var property in element.EnumerateObject())
            {
                var propName = usePascalCase ? property.Name : ToCamelCase(property.Name);
                var (type, needsType) = GetTypeScriptType(property.Value, propName);
                
                sb.AppendLine($"{indentStr}  {propName}{optional}: {type};");
                
                if (needsType)
                {
                    nestedTypes.Add((type, property.Value));
                }
            }
            
            sb.AppendLine($"{indentStr}}}");
            sb.AppendLine();
            
            foreach (var (name, nestedElement) in nestedTypes)
            {
                GenerateInterface(sb, name, nestedElement, indent);
            }
        }
        else
        {
            sb.AppendLine($"{indentStr}}}");
            sb.AppendLine();
        }
    }

    private (string type, bool needsType) GetTypeScriptType(JsonElement element, string propName = "")
    {
        return element.ValueKind switch
        {
            JsonValueKind.String => ("string", false),
            JsonValueKind.Number => ("number", false),
            JsonValueKind.True or JsonValueKind.False => ("boolean", false),
            JsonValueKind.Array => GetArrayType(element, propName),
            JsonValueKind.Object => (ToPascalCase(propName) + "Type", true),
            JsonValueKind.Null => ("null", false),
            _ => ("unknown", false)
        };
    }

    private (string type, bool needsType) GetArrayType(JsonElement element, string propName)
    {
        var firstElement = element.EnumerateArray().FirstOrDefault();
        if (firstElement.ValueKind == JsonValueKind.Undefined)
            return ("unknown[]", false);
        
        var (itemType, needsType) = GetTypeScriptType(firstElement, propName.TrimEnd('s') + "Item");
        return ($"{itemType}[]", needsType);
    }

    private string ToCamelCase(string text)
    {
        if (string.IsNullOrEmpty(text)) return text;
        var words = text.Split(new[] { '_', '-', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        if (!words.Any()) return text;
        return words.First().ToLower() + string.Concat(words.Skip(1).Select(w => char.ToUpper(w[0]) + w.Substring(1).ToLower()));
    }

    private string ToPascalCase(string text)
    {
        if (string.IsNullOrEmpty(text)) return text;
        var words = text.Split(new[] { '_', '-', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        return string.Concat(words.Select(w => char.ToUpper(w[0]) + w.Substring(1).ToLower()));
    }
}
