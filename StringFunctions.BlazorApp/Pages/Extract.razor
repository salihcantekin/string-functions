@page "/extract"

<SeoHead Route="extract" />
@using System.Text.RegularExpressions

<PageTitle>String Extract</PageTitle>

<ToolPageLayout Title="String Extract" Description="Extract portions of text using patterns or positions.">
    <OptionsContent>
        <div class="option-group">
            <span class="option-label">Mode:</span>
            <FluentSelect TOption="string" @bind-Value="@extractMode" Style="min-width: 150px;" @bind-Value:after="Process">
                <FluentOption Value="substring">Substring</FluentOption>
                <FluentOption Value="between">Between delimiters</FluentOption>
                <FluentOption Value="regex">Regex pattern</FluentOption>
                <FluentOption Value="lines">Line range</FluentOption>
            </FluentSelect>
        </div>
        <div class="option-divider"></div>
        @if (extractMode == "substring")
        {
            <div class="option-group">
                <span class="option-label">Start:</span>
                <FluentNumberField @bind-Value="@startIndex" Min="0" Style="width: 70px;" @bind-Value:after="Process" />
            </div>
            <div class="option-group">
                <span class="option-label">Length:</span>
                <FluentNumberField @bind-Value="@length" Min="0" Style="width: 70px;" @bind-Value:after="Process" />
            </div>
        }
        @if (extractMode == "between")
        {
            <div class="option-group">
                <span class="option-label">Start:</span>
                <FluentTextField @bind-Value="@startDelimiter" Placeholder="[" Style="width: 60px;" @bind-Value:after="Process" />
            </div>
            <div class="option-group">
                <span class="option-label">End:</span>
                <FluentTextField @bind-Value="@endDelimiter" Placeholder="]" Style="width: 60px;" @bind-Value:after="Process" />
            </div>
            <FluentCheckbox @bind-Value="@includeDelimiters" Label="Include delimiters" @bind-Value:after="Process" />
        }
        @if (extractMode == "regex")
        {
            <div class="option-group">
                <span class="option-label">Pattern:</span>
                <FluentTextField @bind-Value="@regexPattern" Placeholder="(\d+)" Style="min-width: 150px;" @bind-Value:after="Process" />
            </div>
            <FluentCheckbox @bind-Value="@regexIgnoreCase" Label="Ignore case" @bind-Value:after="Process" />
        }
        @if (extractMode == "lines")
        {
            <div class="option-group">
                <span class="option-label">Lines:</span>
                <FluentTextField @bind-Value="@lineRange" Placeholder="1-5, 10, 15-20" Style="min-width: 150px;" @bind-Value:after="Process" />
            </div>
        }
    </OptionsContent>
    <ChildContent>
        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <FluentMessageBar Title="Error" Intent="MessageIntent.Error" Style="margin-bottom: 8px;">
                @errorMessage
            </FluentMessageBar>
        }

        <div class="io-grid">
            <div class="io-panel">
                <div class="io-panel-header">
                    <span class="io-panel-title">Input</span>
                </div>
                <FluentTextArea @bind-Value="@inputText" 
                               Placeholder="Enter text..."
                               Resize="TextAreaResize.Vertical"
                               @oninput="OnInputChanged" />
            </div>

            <div class="io-panel">
                <div class="io-panel-header">
                    <span class="io-panel-title">Output</span>
                    <CopyButton Text="@outputText" />
                </div>
                <FluentTextArea Value="@outputText" 
                               ReadOnly="true"
                               Resize="TextAreaResize.Vertical" />
            </div>
        </div>
    </ChildContent>
</ToolPageLayout>

<style>
    .io-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        flex: 1;
    }

    .io-panel {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .io-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        height: 32px;
    }

    .io-panel-title {
        font-weight: 600;
        color: var(--text-primary);
    }

    @@media (max-width: 768px) {
        .io-grid {
            grid-template-columns: 1fr;
        }
    }
</style>

@code {
    private string inputText = string.Empty;
    private string outputText = string.Empty;
    private string extractMode = "substring";
    private int startIndex = 0;
    private int length = 0;
    private string startDelimiter = "[";
    private string endDelimiter = "]";
    private bool includeDelimiters = false;
    private string regexPattern = @"(\d+)";
    private bool regexIgnoreCase = false;
    private string lineRange = "1-5";
    private string errorMessage = string.Empty;

    private void OnInputChanged(ChangeEventArgs e)
    {
        inputText = e.Value?.ToString() ?? string.Empty;
        Process();
    }

    private void Process()
    {
        errorMessage = string.Empty;
        
        if (string.IsNullOrEmpty(inputText))
        {
            outputText = string.Empty;
            return;
        }

        try
        {
            outputText = extractMode switch
            {
                "substring" => ExtractSubstring(),
                "between" => ExtractBetween(),
                "regex" => ExtractRegex(),
                "lines" => ExtractLines(),
                _ => inputText
            };
        }
        catch (Exception ex)
        {
            errorMessage = ex.Message;
            outputText = string.Empty;
        }
    }

    private string ExtractSubstring()
    {
        if (startIndex >= inputText.Length) return string.Empty;
        return length == 0 ? inputText.Substring(startIndex) : inputText.Substring(startIndex, Math.Min(length, inputText.Length - startIndex));
    }

    private string ExtractBetween()
    {
        var results = new List<string>();
        var startIdx = 0;

        while (startIdx < inputText.Length)
        {
            var start = inputText.IndexOf(startDelimiter, startIdx);
            if (start == -1) break;

            var end = inputText.IndexOf(endDelimiter, start + startDelimiter.Length);
            if (end == -1) break;

            var extractStart = includeDelimiters ? start : start + startDelimiter.Length;
            var extractEnd = includeDelimiters ? end + endDelimiter.Length : end;
            results.Add(inputText.Substring(extractStart, extractEnd - extractStart));

            startIdx = end + endDelimiter.Length;
        }

        return string.Join("\n", results);
    }

    private string ExtractRegex()
    {
        var options = regexIgnoreCase ? RegexOptions.IgnoreCase : RegexOptions.None;
        var regex = new Regex(regexPattern, options);
        var matches = regex.Matches(inputText);
        return string.Join("\n", matches.Select(m => m.Value));
    }

    private string ExtractLines()
    {
        var lines = inputText.Split('\n');
        var ranges = lineRange.Split(',').Select(r => r.Trim());
        var lineNumbers = new HashSet<int>();

        foreach (var range in ranges)
        {
            if (range.Contains('-'))
            {
                var parts = range.Split('-');
                if (int.TryParse(parts[0], out var start) && int.TryParse(parts[1], out var end))
                {
                    for (int i = start; i <= end; i++)
                        lineNumbers.Add(i);
                }
            }
            else if (int.TryParse(range, out var lineNum))
            {
                lineNumbers.Add(lineNum);
            }
        }

        var result = lineNumbers.OrderBy(n => n)
            .Where(n => n >= 1 && n <= lines.Length)
            .Select(n => lines[n - 1]);

        return string.Join("\n", result);
    }
}
